# API and Frontend

This tutorial covers the FastAPI backend and React frontend that together form the Echelonos web interface. The API serves obligation report data generated by Stage 7, and the frontend renders it as an interactive dashboard with sortable tables, flag panels, evidence drawers, and summary charts.

---

## Table of Contents

- [Architecture Overview](#architecture-overview)
- [FastAPI Backend](#fastapi-backend)
  - [app.py -- Application Setup](#apppy--application-setup)
  - [CORS Configuration](#cors-configuration)
  - [Database-Backed Report Generation](#database-backed-report-generation)
  - [Demo Data Fallback](#demo-data-fallback)
  - [API Endpoints](#api-endpoints)
  - [Upload and Pipeline Endpoints](#upload-and-pipeline-endpoints)
  - [Database Management Endpoints](#database-management-endpoints)
  - [persist.py -- Idempotent Persistence](#persistpy--idempotent-persistence)
  - [demo_data.py -- Sample Data](#demo_datapy--sample-data)
  - [__init__.py](#__init__py)
- [React Frontend](#react-frontend)
  - [Tech Stack](#tech-stack)
  - [Vite Configuration](#vite-configuration)
  - [TypeScript Types](#typescript-types)
  - [Mock Data Fallback](#mock-data-fallback)
  - [App.tsx -- Main Application](#apptsx--main-application)
  - [Component Breakdown](#component-breakdown)
    - [DocumentUpload](#documentupload)
    - [StatsCards](#statscards)
    - [ObligationTable](#obligationtable)
    - [FlagPanel](#flagpanel)
    - [EvidenceDrawer](#evidencedrawer)
    - [SummaryCharts](#summarycharts)
- [Key Takeaways](#key-takeaways)
- [Watch Out For](#watch-out-for)

---

## Architecture Overview

```
Browser (React)          FastAPI Backend           PostgreSQL
  :5173                    :8000                    :5432
    |                        |                        |
    |--- GET /api/orgs ----> |--- query orgs -------> |
    |<-- org list -----------|<-- rows ---------------|
    |                        |                        |
    |--- GET /api/report --> |--- query DB ---------->|
    |                        |   (fallback: demo)     |
    |<-- JSON response ------|<-- ObligationReport ---|
    |                        |                        |
    |--- POST /api/upload -> |--- validate+persist -> |
    |<-- result -------------|                        |
    |                        |                        |
    |--- POST /pipeline/run >|--- stages 1-7 ------> |
    |--- GET /pipeline/status|   (background thread)  |
    |                        |                        |
    | (if API unavailable)   |
    |--- uses mockData.ts    |
```

The frontend development server (Vite on port 5173) proxies `/api/*` requests to the FastAPI backend on port 8000. The backend queries a real PostgreSQL database for organization data and obligation reports, falling back to demo data if the requested organization is not found. If the backend is unavailable entirely, the frontend gracefully falls back to bundled mock data.

---

## FastAPI Backend

### app.py -- Application Setup

**File:** `src/echelonos/api/app.py`

The backend is a substantial file (approximately 970 lines) that imports the Stage 7 report generator, database models and session management, and demo data. It wires up CORS, exposes report endpoints backed by real PostgreSQL queries, and provides upload, pipeline management, and database clearing endpoints.

#### Application Creation (lines 29--33)

```python
app = FastAPI(
    title="Echelonos API",
    description="Contract obligation extraction and report API",
    version="0.1.0",
)
```

The `FastAPI` instance is created at module level (not inside a factory function). This means it can be started directly with `uvicorn echelonos.api.app:app --reload` as documented in the module docstring (lines 8--9). The `title` and `description` are used by the auto-generated OpenAPI/Swagger documentation at `/docs`.

### CORS Configuration

**File:** `src/echelonos/api/app.py`, lines 36--47

```python
app.add_middleware(
    CORSMiddleware,
    allow_origins=[
        "http://localhost:5173",
        "http://127.0.0.1:5173",
        "http://localhost:3000",
        "http://127.0.0.1:3000",
    ],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)
```

Four origins are explicitly allowed:

- `localhost:5173` and `127.0.0.1:5173` -- Vite dev server (the default Vite port).
- `localhost:3000` and `127.0.0.1:3000` -- Alternative React dev server port (Create React App default).

Both `localhost` and `127.0.0.1` variants are included because browsers treat them as different origins. `allow_methods=["*"]` and `allow_headers=["*"]` are permissive settings suitable for development. In production, these should be tightened.

### Database-Backed Report Generation

**File:** `src/echelonos/api/app.py`, lines 89--171

The API now queries the real PostgreSQL database first and falls back to demo data only when the requested organization is not found in the database.

Three private helpers work together:

```python
def _get_real_report(org_name: str, db: Session) -> ObligationReport | None:
    """Query the database and build a report for *org_name*.
    Returns None if the organization is not found."""
    org = db.query(Organization).filter(func.lower(Organization.name) == org_name.lower()).first()
    if org is None:
        return None
    # ... fetches documents, obligations, links from DB ...
    return generate_report(org_name=org_name, obligations=obligations, documents=documents, links=links)

def _get_report(org_name: str, db: Session) -> ObligationReport:
    """Try real DB first, fall back to demo data."""
    try:
        report = _get_real_report(org_name, db)
        if report is not None:
            return report
    except Exception:
        logger.exception("Failed to query DB for org %s, falling back to demo data", org_name)
    return _get_demo_report(org_name)
```

The `_get_real_report()` function performs a case-insensitive lookup of the organization, then fetches all documents, obligations, and document links from the database. It converts the SQLAlchemy ORM objects into dicts matching `generate_report()`'s expected signatures. If the organization is not found or has no documents, it returns `None`.

The `_get_report()` function wraps this with exception handling: if the DB query fails for any reason, it logs the error and falls back to `_get_demo_report()`, ensuring the API always returns a valid response.

### Demo Data Fallback

**File:** `src/echelonos/api/app.py`, lines 79--86

```python
def _get_demo_report(org_name: str) -> ObligationReport:
    return generate_report(
        org_name=org_name,
        obligations=DEMO_OBLIGATIONS,
        documents=DEMO_DOCUMENTS,
        links=DEMO_LINKS,
    )
```

This private helper calls the Stage 7 `generate_report()` function with hardcoded demo data. It is now used only as a fallback when the requested organization does not exist in the database or when a database error occurs.

### API Endpoints

**File:** `src/echelonos/api/app.py`, lines 178--218

#### Report Endpoints

| Endpoint | Method | Response Model | Description |
|----------|--------|----------------|-------------|
| `/api/health` | GET | `dict` | Health check returning `{"status": "ok", "service": "echelonos-api"}` |
| `/api/organizations` | GET | `list[dict]` | List all organizations in the database |
| `/api/report/{org_name}` | GET | `ObligationReport` | Full report with all sections |
| `/api/report/{org_name}/obligations` | GET | `list[ObligationRow]` | Just the obligation matrix rows |
| `/api/report/{org_name}/flags` | GET | `list[FlagItem]` | Just the flag report |
| `/api/report/{org_name}/summary` | GET | `dict` | Just the summary statistics |

All report endpoints now use `_get_report()`, which queries the PostgreSQL database first and falls back to demo data if the organization is not found. Each endpoint takes a `db: Session = Depends(get_db)` parameter, injected by FastAPI's dependency system.

The `/api/organizations` endpoint is new -- it queries the `Organization` table and returns a list of `{id, name}` dicts, ordered by name. The frontend uses this to populate the organization selector dropdown.

### Upload and Pipeline Endpoints

**File:** `src/echelonos/api/app.py`, lines 222--577

| Endpoint | Method | Description |
|----------|--------|-------------|
| `POST /api/upload` | POST | Upload documents (or a zip), validate, dedup, and persist to DB |
| `GET /api/pipeline/status` | GET | Return current pipeline processing status |
| `POST /api/pipeline/run` | POST | Launch stages 1--7 in a background thread |
| `POST /api/pipeline/stop` | POST | Request cancellation of the running pipeline |

The **upload endpoint** (`POST /api/upload`) accepts multipart file uploads. If a single `.zip` file is uploaded, it is extracted and the zip filename (minus extension) becomes the organization name. For multiple files, the org name is derived from the longest common prefix of filenames. The endpoint runs Stage 0a validation and Stage 0b deduplication, then persists results to the database using `persist.py` helpers.

The **pipeline run endpoint** (`POST /api/pipeline/run`) accepts an `org_name` query parameter, validates the organization exists with documents, and launches stages 1--7 in a background daemon thread. A module-level `_pipeline_status` dict tracks state transitions (`idle -> processing -> done/error/cancelled`), current stage, per-document progress, and elapsed time.

The **pipeline stop endpoint** (`POST /api/pipeline/stop`) sets a `threading.Event` that the background thread checks between stages and between documents, enabling cooperative cancellation.

The **pipeline status endpoint** (`GET /api/pipeline/status`) returns the current `_pipeline_status` dict with a live `elapsed_seconds` calculation when processing is active.

### Database Management Endpoints

**File:** `src/echelonos/api/app.py`, lines 467--493

| Endpoint | Method | Description |
|----------|--------|-------------|
| `DELETE /api/database` | DELETE | Delete ALL data from every table |

The clear database endpoint deletes rows in dependency order (children before parents) to avoid foreign key constraint violations: dangling references, flags, evidence, obligations, pages, fingerprints, document links, documents, and finally organizations. It returns a dict of deleted counts per table and resets the pipeline status.

### persist.py -- Idempotent Persistence

**File:** `src/echelonos/db/persist.py`

This module provides get-or-create and upsert helper functions for idempotent ingestion. Every function queries by the table's unique key first. If the row exists, mutable fields are updated in-place; otherwise a new row is created. This uses SQLAlchemy ORM only (no raw SQL, no `on_conflict`).

Key functions:

| Function | Description |
|----------|-------------|
| `get_or_create_organization(db, name, folder_path)` | Find or create an organization by name |
| `upsert_document(db, org_id, file_path, filename, ...)` | Upsert a document by `(org_id, filename)` |
| `upsert_obligation(db, doc_id, source_clause, ...)` | Upsert an obligation by `(doc_id, source_clause)` |
| `upsert_document_link(db, child_doc_id, ...)` | Upsert a document link by `child_doc_id` |
| `upsert_page(db, doc_id, page_number, ...)` | Upsert a page by `(doc_id, page_number)` |

The idempotent design means re-uploading the same documents or re-running the pipeline produces no duplicates -- existing rows are updated instead of duplicated.

### demo_data.py -- Sample Data

**File:** `src/echelonos/api/demo_data.py`

This file defines three constants that simulate a realistic vendor contract scenario:

#### DEMO_DOCUMENTS (lines 17--42)

A dict mapping `doc_id` to document metadata. Three documents are defined:

- `doc-001`: An MSA (Master Services Agreement) between Acme Corp and Nexus Solutions
- `doc-002`: Amendment #1 (uploaded 2024-09-01)
- `doc-003`: Amendment #2 (uploaded 2025-01-20)

Each document dict includes `id`, `doc_type`, `filename`, `org_name`, `upload_date`, and `classification_confidence`.

#### DEMO_LINKS (lines 48--61)

A list of two link entries, both with status `"LINKED"`:

- `doc-002` (Amendment #1) linked to `doc-001` (MSA) with confidence 0.96
- `doc-003` (Amendment #2) linked to `doc-001` (MSA) with confidence 0.89

This creates a two-amendment chain: MSA -> Amendment #1, MSA -> Amendment #2.

#### DEMO_OBLIGATIONS (lines 67--245)

Ten obligations spanning the full range of statuses and types:

| ID | Status | Type | Confidence | Notes |
|----|--------|------|------------|-------|
| obl-001 | ACTIVE | Delivery | 0.95 | Monthly reports, verified |
| obl-002 | ACTIVE | Financial | 0.98 | Net 30 payment, verified |
| obl-003 | ACTIVE | Compliance | 0.93 | SOC 2 audit, verified |
| obl-004 | ACTIVE | SLA | 0.97 | 99.9% uptime, verified |
| obl-005 | ACTIVE | Confidentiality | 0.96 | 5-year NDA, verified |
| obl-006 | SUPERSEDED | Delivery | 0.88 | Quarterly business reviews, verified |
| obl-007 | UNRESOLVED | Delivery | 0.72 | **Verification failed** -- source clause not grounded |
| obl-008 | ACTIVE | Financial | 0.65 | **Low confidence + unverified** -- OCR issues |
| obl-009 | TERMINATED | Delivery | 0.91 | Dedicated account manager, verified |
| obl-010 | ACTIVE | SLA | 0.94 | Incident response SLA, verified |

Notice that `obl-007` and `obl-008` are designed to trigger flags:
- `obl-007` has `verification_result.verified = False` (triggers UNVERIFIED RED flag) and confidence 0.72 (triggers LOW_CONFIDENCE WHITE flag).
- `obl-008` has `verification_result.verified = False` (triggers UNVERIFIED RED flag) and confidence 0.65 (triggers LOW_CONFIDENCE WHITE flag).

### __init__.py

**File:** `src/echelonos/api/__init__.py`

This file is empty (just a newline). It exists solely to make `echelonos.api` a proper Python package so that imports like `from echelonos.api.app import app` work.

---

## React Frontend

### Tech Stack

**File:** `frontend/package.json`

| Dependency | Version | Purpose |
|------------|---------|---------|
| `react` | ^19.0.0 | UI framework |
| `react-dom` | ^19.0.0 | DOM rendering |
| `clsx` | ^2.1.1 | Conditional CSS class joining |
| `lucide-react` | ^0.468.0 | Icon library |
| `tailwindcss` | ^4.0.0 | Utility-first CSS (dev dependency) |
| `@tailwindcss/vite` | ^4.0.0 | Tailwind v4 Vite plugin |
| `vite` | ^6.0.0 | Build tool and dev server |
| `typescript` | ~5.6.0 | Type safety |
| `@vitejs/plugin-react` | ^4.3.0 | React Fast Refresh for Vite |

Notable: This project uses **Tailwind CSS v4** with the Vite plugin integration (`@tailwindcss/vite`), not the traditional PostCSS plugin. There is no `tailwind.config.js` file -- the configuration is handled through the Vite plugin. Also notable is **React 19**, the latest major version.

The available npm scripts (lines 6--11):

- `dev`: Start Vite dev server (with HMR)
- `build`: TypeScript compile + Vite production build
- `lint`: ESLint
- `preview`: Preview the production build locally

### Vite Configuration

**File:** `frontend/vite.config.ts`

```typescript
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'
import tailwindcss from '@tailwindcss/vite'

export default defineConfig({
  plugins: [react(), tailwindcss()],
  server: {
    proxy: {
      '/api': 'http://localhost:8000'
    }
  }
})
```

The key feature here is the **proxy configuration** on lines 8--10. All requests to `/api/*` from the Vite dev server are forwarded to `http://localhost:8000` (the FastAPI backend). This eliminates CORS issues during development and mirrors a production reverse proxy setup.

The `tailwindcss()` Vite plugin (line 6) handles CSS processing inline during development, with no separate build step needed.

### TypeScript Types

**File:** `frontend/src/types.ts`

This file defines four TypeScript interfaces that mirror the Python Pydantic models from Stage 7:

#### ObligationRow (lines 1--15)

```typescript
export interface ObligationRow {
  number: number;
  obligation_text: string;
  obligation_type: string;
  responsible_party: string;
  counterparty: string;
  source: string;
  status: 'ACTIVE' | 'SUPERSEDED' | 'TERMINATED' | 'UNRESOLVED';
  frequency: string | null;
  deadline: string | null;
  confidence: number;
  source_clause?: string;
  source_page?: number;
  doc_filename?: string;
}
```

This matches the Python `ObligationRow` model with three **extra optional fields** (lines 12--14): `source_clause`, `source_page`, and `doc_filename`. These are used by the `EvidenceDrawer` component to display the original source text. They come from the mock data but are not part of the Python API response -- the mock data enriches each obligation with provenance information for the UI demo.

Note the `status` field uses a **union literal type** (line 8), constraining it to exactly the four valid values.

#### FlagItem (lines 17--23)

```typescript
export interface FlagItem {
  flag_type: string;
  severity: 'RED' | 'ORANGE' | 'YELLOW' | 'WHITE';
  entity_type: string;
  entity_id: string;
  message: string;
}
```

Matches the Python `FlagItem` model exactly. `severity` uses a union literal type.

#### SummaryData (lines 25--29)

```typescript
export interface SummaryData {
  by_type: Record<string, number>;
  by_status: Record<string, number>;
  by_responsible_party: Record<string, number>;
}
```

Note a **naming discrepancy**: the Python summary uses `by_party` but the TypeScript interface uses `by_responsible_party`. Also, the Python summary includes `flags_by_severity` and `flags_by_type` which are absent from this TypeScript type. This means the flag summary data from the API is currently unused in the frontend charts.

#### ObligationReport (lines 31--41)

```typescript
export interface ObligationReport {
  org_name: string;
  generated_at: string;
  total_obligations: number;
  active_obligations: number;
  superseded_obligations: number;
  unresolved_obligations: number;
  obligations: ObligationRow[];
  flags: FlagItem[];
  summary: SummaryData;
}
```

Matches the Python `ObligationReport` model.

### Mock Data Fallback

**File:** `frontend/src/mockData.ts`

This file exports a single `mockReport` constant (474 lines) that provides a complete `ObligationReport` for offline development. It contains:

- **24 obligations** spanning ACTIVE (16), SUPERSEDED (5), and UNRESOLVED (3) statuses
- **11 flags** across all severity levels
- **Summary statistics** matching the obligation distribution

Each obligation in the mock data includes the optional `source_clause`, `source_page`, and `doc_filename` fields (lines 22--24, 37--39, etc.) that the `EvidenceDrawer` component uses. The API demo data does not include these fields -- they are a frontend-only enrichment.

The mock data is significantly more detailed than the API demo data (24 obligations vs. 10), providing a richer UI experience when developing without the backend.

### App.tsx -- Main Application

**File:** `frontend/src/App.tsx`

The root component manages global state and renders the page layout.

#### State Management (lines 21--27)

```typescript
const [report, setReport] = useState<ObligationReport | null>(null);
const [loading, setLoading] = useState(false);
const [error, setError] = useState<string | null>(null);
const [activeTab, setActiveTab] = useState<Tab>('obligations');
const [selectedObligation, setSelectedObligation] = useState<ObligationRow | null>(null);
const [organizations, setOrganizations] = useState<OrgOption[]>([]);
const [selectedOrg, setSelectedOrg] = useState<string>('');
```

Seven pieces of state:
- `report` -- The loaded report data (or null while loading)
- `loading` -- Loading indicator (initialized to `false`, not `true`, since the app now waits for the org list before fetching)
- `error` -- Error message
- `activeTab` -- Which tab is active: `'obligations'`, `'flags'`, or `'summary'`
- `selectedObligation` -- When set, opens the `EvidenceDrawer`
- `organizations` -- List of `{id, name}` objects fetched from `GET /api/organizations`
- `selectedOrg` -- The currently selected organization name, used to fetch the report

#### Organization Fetching (lines 29--51)

```typescript
const fetchOrganizations = useCallback(async () => {
  try {
    const res = await fetch('/api/organizations');
    if (res.ok) {
      const orgs: OrgOption[] = await res.json();
      setOrganizations(orgs);
      return orgs;
    }
  } catch {
    // API not available
  }
  return [];
}, []);
```

On mount, the app fetches the list of available organizations from the API. If organizations are found, it automatically selects the first one, which triggers the report fetch via the `useEffect` dependency chain.

#### Report Fetching (lines 53--76)

```typescript
const fetchReport = useCallback(async () => {
  if (!selectedOrg) {
    setReport(null);
    setLoading(false);
    return;
  }
  setLoading(true);
  setError(null);
  try {
    const res = await fetch(`/api/report/${encodeURIComponent(selectedOrg)}`);
    if (res.ok) {
      const data: ObligationReport = await res.json();
      setReport(data);
    } else {
      console.info('API not available, using mock data');
      setReport(mockReport);
    }
  } catch {
    console.info('Network error, using mock data');
    setReport(mockReport);
  } finally {
    setLoading(false);
  }
}, [selectedOrg]);
```

The fetch logic uses a **graceful degradation pattern**:

1. If no organization is selected, clear the report and return early.
2. Try to fetch from `/api/report/{selectedOrg}` (URL-encoded).
3. If the response is not OK (e.g., 500, 404), fall back to `mockReport`.
4. If there is a network error (backend not running), fall back to `mockReport`.

This means the frontend **always works**, even without the backend. The `useCallback` depends on `selectedOrg`, so changing the selected organization triggers a new fetch.

Additional callbacks include `handleRefresh` (re-fetches org list and report), `refreshAfterUpload` (called after document upload to refresh the org list), and `handleClearDatabase` (calls `DELETE /api/database` and resets all state).

#### Tab Navigation (lines 47--51)

```typescript
const tabs: { id: Tab; label: string; icon: typeof Table2 }[] = [
  { id: 'obligations', label: 'Obligations', icon: Table2 },
  { id: 'flags', label: 'Flags', icon: Flag },
  { id: 'summary', label: 'Summary', icon: BarChart3 },
];
```

Three tabs, each with an icon from Lucide. The Flags tab includes a badge showing the flag count (lines 152--155) when there are flags present.

#### Layout Structure (lines 125--281)

The page layout is:

1. **Header** (lines 128--187): Dark slate background with the Echelon OS branding, an organization selector dropdown (shown when organizations are available), generation timestamp, and a Refresh button.
2. **Main content** (lines 190--273): DocumentUpload component, loading state, error state, or the report content.
3. **DocumentUpload** (line 192--196): Always rendered at the top of main content, providing file upload, pipeline run/stop, and database clearing functionality.
4. **Report content** (lines 220--271): StatsCards -> Tab bar -> Tab content.
5. **Evidence drawer** (lines 276--279): Rendered outside the main content flow. It is always mounted but only visible when `selectedObligation` is non-null.

---

### Component Breakdown

#### DocumentUpload

**File:** `frontend/src/components/DocumentUpload.tsx`

A full-featured document ingestion panel (approximately 608 lines) that provides file upload, pipeline execution controls, and database management.

**Props** (lines 30--34):
```typescript
interface DocumentUploadProps {
  onUploadComplete: () => void;
  onClearDatabase: () => Promise<void>;
  selectedOrg: string;
}
```

**Key features:**

1. **Drag-and-drop file upload**: A drop zone accepts files or a single `.zip` organization folder. Supported formats: PDF, DOCX, HTML, XLSX, PNG, JPG, ZIP, MSG. Files are de-duplicated by name+size before display.

2. **Upload and Process button**: Sends selected files as multipart form data to `POST /api/upload`. The endpoint runs Stage 0a validation and Stage 0b deduplication, then persists valid unique files to the database.

3. **Run Pipeline button**: Triggers `POST /api/pipeline/run?org_name={selectedOrg}` to launch stages 1--7 in a background thread on the server. The component polls `GET /api/pipeline/status` every 1.5 seconds and displays live progress including the current stage, per-document progress bar (for stages 1--3), completed stage chips, and elapsed time.

4. **Stop Pipeline button**: Visible only while the pipeline is processing. Sends `POST /api/pipeline/stop` to request cooperative cancellation.

5. **Clear Database button**: Two-step confirmation flow. Calls `DELETE /api/database` to remove all data from every table, then resets local state.

**Pipeline status tracking**: The component uses a `PipelineStatus` interface from `types.ts` that mirrors the server-side `_pipeline_status` dict structure. Status banners are color-coded: emerald for done, red for error, amber for cancelled.

#### StatsCards

**File:** `frontend/src/components/StatsCards.tsx`

A simple grid of four KPI cards showing top-level metrics:

| Card | Icon | Left Border Color |
|------|------|-------------------|
| Total Obligations | Activity | Blue |
| Active | CheckCircle | Emerald |
| Superseded | AlertTriangle | Amber |
| Flags | Flag | Red |

The component accepts four numeric props (line 10): `total`, `active`, `superseded`, `flagCount`. The cards use a left border accent via Tailwind's `border-l-4` class (line 53).

The grid is responsive: 1 column on mobile, 2 on `sm`, 4 on `lg` (line 47: `grid-cols-1 sm:grid-cols-2 lg:grid-cols-4`).

#### ObligationTable

**File:** `frontend/src/components/ObligationTable.tsx`

The most complex frontend component (249 lines). It provides an interactive data table with sorting, filtering, and search.

**Props** (lines 6--9):
```typescript
interface ObligationTableProps {
  obligations: ObligationRow[];
  onRowClick: (obligation: ObligationRow) => void;
}
```

**State** (lines 34--38):
- `sortKey` -- Which column to sort by (default: `'number'`)
- `sortDir` -- `'asc'` or `'desc'`
- `statusFilter` -- Selected status filter (default: `'All'`)
- `typeFilter` -- Selected type filter (default: `'All'`)
- `searchText` -- Free-text search input

**Filtering and Sorting** (lines 47--70):

The `useMemo` hook computes filtered/sorted rows whenever any filter or sort state changes:

1. Clone the obligations array.
2. Apply status filter if not `'All'`.
3. Apply type filter if not `'All'`.
4. Apply text search (case-insensitive `includes` on `obligation_text`).
5. Sort by the selected key, handling both numeric and string comparisons.

**Type filter derivation** (lines 40--43): The available type filter options are dynamically derived from the obligation data using a `Set`, ensuring only types present in the data appear in the dropdown.

**Sort toggling** (lines 72--79): Clicking the same column header toggles direction; clicking a different column resets to ascending.

**Visual details**:
- Status badges use color-coded backgrounds (lines 14--19): ACTIVE=emerald, SUPERSEDED=amber, TERMINATED=red, UNRESOLVED=slate.
- Confidence is rendered as a colored progress bar + percentage (lines 228--239). Colors: >=90% emerald, >=80% amber, <80% red.
- Rows are clickable (line 200: `onClick={() => onRowClick(obl)}`), triggering the evidence drawer.
- Obligation text is clamped to 2 lines (line 205: `line-clamp-2`).

#### FlagPanel

**File:** `frontend/src/components/FlagPanel.tsx`

Groups flags by severity level and renders them as styled cards.

**Severity ordering** (line 9):
```typescript
const SEVERITY_ORDER: FlagItem['severity'][] = ['RED', 'ORANGE', 'YELLOW', 'WHITE'];
```

Flags are grouped using a `useMemo` hook (lines 41--52) that creates a `Map<string, FlagItem[]>`. The iteration order follows `SEVERITY_ORDER`, so RED flags always appear first.

**Visual design**:
- Each severity group has a header with a colored dot (lines 71--82).
- Each flag card has a severity-appropriate background color (lines 18--23: `SEVERITY_BG`).
- Flag types are shown as colored badges (lines 32--38: `FLAG_TYPE_COLOR`) with underscores replaced by spaces (line 101: `flag.flag_type.replace(/_/g, ' ')`).
- Each card shows the entity type and ID at the bottom (lines 105--113).

**Empty severity groups are skipped** (line 66: `if (items.length === 0) return null;`), so a report with no RED flags will not show an empty RED section.

#### EvidenceDrawer

**File:** `frontend/src/components/EvidenceDrawer.tsx`

A slide-over drawer that displays detailed information about a selected obligation.

**Early return** (line 31): If `obligation` is null, the component renders nothing. This means the drawer is always mounted in the component tree but only produces DOM elements when an obligation is selected.

**Backdrop** (lines 35--38): A semi-transparent overlay (`bg-black/30`) that closes the drawer when clicked. The `z-40` ensures it sits above normal content.

**Drawer panel** (lines 41--165): Fixed position on the right side, full height, max width of `lg` (32rem). Contents include:

1. **Header** (lines 43--57): Obligation number and close button.
2. **Status and confidence** (lines 62--82): Status badge and confidence progress bar, using the same color logic as the table.
3. **Obligation text** (lines 85--92): Full obligation text in a styled container.
4. **Source clause** (lines 95--120): If `source_clause` is present, shown in a blue-tinted container with the original quoted text, filename, and page number.
5. **Details grid** (lines 123--163): A 2-column grid of `DetailCard` sub-components showing type, responsible party, counterparty, source, frequency, and deadline.

The `DetailCard` sub-component (lines 170--188) is a reusable card with an icon, label, and value. It is only used within this file and is not exported.

#### SummaryCharts

**File:** `frontend/src/components/SummaryCharts.tsx`

Renders three horizontal bar charts in a responsive 3-column grid.

**HorizontalBarChart** (lines 36--77): A reusable sub-component that:
1. Sorts entries by count descending (line 47).
2. Calculates the maximum value for scaling (line 48).
3. Renders each entry as a label, count, and a proportionally-width bar.

The component supports two color modes:
- `colorMap` -- A fixed mapping of label to color (used for status bars where ACTIVE is always emerald).
- `colorList` -- A cycling list of colors (used for type and party bars where colors are assigned by index).

**Three charts rendered** (lines 79--98):
1. "Obligations by Type" -- Uses `TYPE_COLORS` (10 colors that cycle).
2. "Obligations by Status" -- Uses `STATUS_BAR_COLORS` (fixed mapping).
3. "Obligations by Responsible Party" -- Uses `PARTY_COLORS` (5 colors that cycle).

The grid is responsive: 1 column on mobile, 3 columns on `md` (line 81: `grid-cols-1 md:grid-cols-3`).

---

## Key Takeaways

1. **The API is backed by a real database.** Report endpoints query PostgreSQL for organizations, documents, obligations, and links. The demo data fallback only activates when an organization is not found in the database, ensuring the API always returns a valid response.

2. **Graceful degradation is built in.** The frontend works with or without the backend, thanks to the mock data fallback. This makes development and demos easy -- you can run just `npm run dev` without starting any backend.

3. **The proxy setup eliminates CORS pain.** Vite proxies `/api/*` to the backend, so the frontend always makes same-origin requests in development. The backend CORS config is a safety net, not the primary mechanism.

4. **TypeScript types mirror Python models.** The `types.ts` file should be kept in sync with the Pydantic models in Stage 7. When you add a field to `ObligationReport`, add it to both.

5. **Idempotent persistence prevents duplicates.** The `persist.py` helpers use get-or-create / upsert patterns, so re-uploading the same documents or re-running the pipeline does not create duplicate rows.

6. **Pipeline management uses cooperative cancellation.** The background thread checks a `threading.Event` between stages and between documents, allowing the user to stop a long-running pipeline gracefully.

7. **Component responsibilities are clean.** Each component handles one concern: DocumentUpload manages file ingestion and pipeline controls, StatsCards shows metrics, ObligationTable handles data display with filtering/sorting, FlagPanel groups and renders flags, EvidenceDrawer shows details, SummaryCharts visualizes aggregates.

---

## Watch Out For

1. **SummaryData naming mismatch.** The Python summary uses `by_party` but the TypeScript `SummaryData` interface uses `by_responsible_party`. If you fetch real API data (not mock), the `SummaryCharts` component may render an empty "Obligations by Responsible Party" chart because the key does not match. You need to align the field names between Python and TypeScript.

2. **Missing flag summary in TypeScript types.** The Python summary includes `flags_by_severity` and `flags_by_type`, but the `SummaryData` TypeScript interface omits them. To display flag severity distribution in the charts, you would need to extend the interface and add a fourth chart.

3. **The EvidenceDrawer relies on optional fields.** The `source_clause`, `source_page`, and `doc_filename` fields are present in mock data but not in the Python API response model. When running against the real API, the source clause section of the drawer will not render because these fields will be `undefined`.

4. **Pipeline status is in-process only.** The `_pipeline_status` dict and `_pipeline_thread` are module-level globals. If the API server restarts during a pipeline run, the status is lost. This is acceptable for single-user development but would need external state (e.g., Redis, database) for production.

5. **The ObligationTable search is case-insensitive but only searches `obligation_text`.** It does not search the source, type, or party fields. Users might expect a broader search scope.

6. **No `tailwind.config.js` exists.** Tailwind v4 with the Vite plugin does not require a config file. If you see references to `tailwind.config.js` in older documentation or tooling, they are outdated for this project's setup.

7. **The clear database endpoint is destructive.** `DELETE /api/database` drops all data from all tables with no undo. The frontend has a two-step confirmation, but the API itself has no protection. Be careful in any shared environment.
